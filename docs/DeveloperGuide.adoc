= Dr. Duke - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:xrefstyle: full
:repoURL: https://github.com/AY1920S1-CS2113-T14-1/main/tree/master

By: `CS2113-T14-1`      Since: `Sept 2019`      Licence: `MIT`

== Introduction

Welcome to the *Dr. Duke* developer guide! This document assumes a familiarity with the link:UserGuide.adoc[user guide].

In order to be a successful *Dr. Duke* developer, you need a general understanding of: +

* *Dr. Duke*'s architecture and object model
* The Java framework which *Dr. Duke* builds on

== Setting up
=== Prerequisites

. *JDK `11`* or above
. *IntelliJ* IDE
+

NOTE: IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +

This will generate all resources required by the application and tests.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* shown above explains the high-level design of *Dr. Duke*.

[[Design-UI]]
=== UI
image::plantuml/ui.svg[]

This class diagram aptly describes the relationships between the various core classes in the UI component.

The `UI` component uses the JavaFX UI framework. The layout of these UI elements are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/duke/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`].

The UI component is exposed to external modules/components via the `Ui` interface. The `UiManager` implements this interface and acts as the manager of the UI component. Hence, `UiManager` holds a reference to the `MainWindow` (the primary UI window that houses the other UI elements that the application will use).

As mentioned, the UI is made up of a `MainWindow` that houses various UI elements such as `CommandWindow`, `HomeWindow`, `PatientWindow`, etc. These UI elements, including `MainWindow` extends from the abstract class `UiElement`. This abstract class serves as the base class for ALL UI elements used in the application, and allows for their easy creation.

[[Design-Logic]]
=== Parser Logic
image::plantuml/logic.svg[]

This class diagram describes the relationships between the various core classes involved in parsing the user's input into `Commands`. The first word (delimited by a space or newline) of the user's input is the _command name_. All commands extend the `Command` abstract class, which provides enough functionality for basic commands consisting of a single word. The operation of the `Command` is specified in the `execute` method. The mapping from the command name to the `Command` should be created in the `Commands` class, which is loaded by the default Parser constructor. A Parser can be constructed with a subclass of `Commands` to specify a different set of commands.

==== Parsing

The Parser class scans through a user supplied string. The first word is extracted, and if the corresponding command is an `ArgCommand`, it uses several nested finite state machines which switch on the characters in the input the scan the rest of the input. Switches are extracted, using the aliases in `switchAliases` to identify the full names of the corresponding switches. The switch arguments are then compared against the requirements of the `ArgCommand`, as stored in the `switchMap`.

The finite state machine (FSM) for input parsing has the following states:
* `EMPTY`: parsing whitespace, which has no semantic meaning aside from serving as a separator
* `ARG`: parsing an argument that is not quoted, which may be for a switch or for the command itself
* `STRING`: parsing an argument that is surrounded by double quotes
* `SWITCH`: parsing a switch name

The state transitions are illustrated by the following state diagram: `Work in Progress`

Preceding any transition charater with a backslash `\` will escape it, allowing it to be treated as an ordinary character.

When transitioning from `EMPTY` to any other state, `checkInputAllowed()` is used to check if input is allowed at that point. While in the `ARG`, `STRING` or `SWITCH` states, each character that is read is added to a StringBuilder `elementBuilder`. When exiting the state, the string is processed as a switch, or written to the `Command` being constructed as an argument for the `Command` itself, or as a switch argument, with appropriate checks being performed. For more details on how switches are processed, see below on `Command` objects, and on the <<Feature-Switch-Autocorrect,Switch Autocorrect>> feature.

==== Commands

All commands that have arguments extend `ArgCommand`. Each `ArgCommand` is associated with an `ArgSpec` singleton, whose private constructor sets the parameters of the `ArgCommand`: `emptyArgMsg` (the error message when no argument is supplied), `cmdArgLevel` (an `ArgLevel` enum indicating whether an argument for the command is necessary, optional, or forbidden) and the data structures `switchMap` and `switchAliases`, generated by the `switchInit()` function. The `switchInit()` function takes a vararg of `Switch` objects, which should specify the switches for the particular `Command`.

`switchMap` maps the full name of a switch to a `Switch` object, describing its properties, and `switchAliases` maps _aliases_ to the full name of the switch they represent. An alias is a string that, when provided by the user as a switch, is recognised as a specific switch. For example, for the switch `investigation` (given as `-i[nv(x|estigation)` in the User Guide) has the following aliases:

* `i`
* `in`
* `inv`
* `invx`
* `inve`
* `inves`
* `invest`
* `investi`
* `investig`
* `investiga`
* `investigat`
* `investigati`
* `investigatio`
* `investigation`

As this would be very tedious to list manually, it is automatically generated by the `switchInit()` function, using the data in the `Switch` objects provided to it. Observe that almost all these aliases are prefixes of the word `investigation`, with the shortest being `i`. This follows from the requirement that the switch can be recognised as long as the user has input enough characters for it to be unambiguous. Let `i` in this example be the _root_, the shortest unambiguous part of the full name of the switch. Then, every prefix of the word `investigation` starting from the root is an alias of the switch `investigation`. All aliases of this form are generated by a loop in `switchInit()`, from the root and the full name in the `Switch` object. Any additional aliases can be supplied via the `aliases` vararg in the `Switch` constructor. Refer to the Javadoc of `Switch` for further details on its fields.

In summary, to define a new `Command`:
* define a subclass of `Command`
* specify its execution in `execute`
* update `Commands` to link the command name to the `Command`

If this is an `ArgCommand`, in addition to doing the above for a subclass of `ArgCommand`:
* define a subclass of `ArgSpec` (by convention, `<name>Spec` is associated with `<name>Command`)
* define the private static field `spec` and the public static `getSpec` to provide singleton behaviour
* create a private constructor for the subclass
** define `cmdArgLevel` and `emptyArgMsg`
** construct the switches for the `ArgCommand` and supply them as arguments to `switchInit()`

[[Design-Model]]
=== Data Model

.Class Diagram
image::ClassDiagram.svg[]

The *_Class Diagram_* shown above describes the relationship among the different data classes used in *Dr. Duke*.

The `statusArr` stores the textual description of each numerical value for the `status`.

[[Design-Storage]]
=== Storage System 
image::ClassDiagramData.png[]

This class diagram describes the relationship between the Storage class, `GsonStorage`, the patient class, `Patient`, and the other classes used to describe and handle patient data. 
 
The storage/load mechanism is facilitated by `GsonStorage`. `GsonStorage` uses the Google-developed Java Library `Gson 2.8.6`. `Gson` is a library that can be used to convert Java Objects into their `JSON` representation. It can also be used to convert `JSON` representations back to the equivalent Java` Object. For more information about `Gson` refer to the `Gson` User Guide at https://github.com/google/gson/blob/master/UserGuide.md. 
 
The `JSON` representations of the patients are stored in a `JSON` file called `patients.json`. 
 
 
`GsonStorage` implements the following operations: 

* `HashMap<String, Patient> loadPatientHashMap()`- Loads all the patients in `patients.json` to the hashmap `patientObservableMap`

* `void writeJsonFile(HashMap<String, Patient> patientMap)`- Creates an array containing the patients in `patientObservableMap` and writes the arrays `JSON` representation to `patients.json`

* `String getFilePath()`- returns the filepath to `patients.json`

* `PatientMap resetAllData()`- Clears `patients.json` and returns an empty hash map

 
When the user boots `Dr.Duke` a `GsonStorage` and a `PatientMap` object is created. The method `loadPatientHashmap` in `GsonStorage` is then executed which extracts all the `JSON` representations of the patients in `patients.json` as a string. The `GSON` method `fromJson()` is then executed on the `JSON` representation of the patients which creates the equivalent java array contaning `Patient` objects. The array is iterated through and every patient is loaded into the `patientObservableMap` attribute of the `PatientMap` object. 
 
During runtime, every new patient that is created is stored in the `patientObservableMap`. 
 
When the user shuts down `Dr.Duke` the `patientObservableMap` is sent back to the `GsonStorage` object by calling the `writeJsonFile` method on the `GsonSotrage` object. The `writeJsonFile` method iterates through the `patientObservableMap` and places every `Patient` object in a java array. When all the patients are in the array the arrays `JSON` representation is created using the `Gson` method `toJson()`. The context of the `patient.son` file is then cleared and the new `JSON` representation of the array containing all the patients is written to the `patient.json` file which concludes the storage circle. 
 
As can be seen in the class diagram, every individual's patient's data in nested from the `Patient` object representing that patient. The diagram also displays that there are no circle references. For these two reasons, using `Gson` to store all the data about the different patients is very convenient and effective as everything can be stored by simply creating the `JSON` representations of each `Patient` object and the rest of the nesting will be parsed automatically by the `Gson` source code. 
 
If further development of `Dr.Duke` requires the storage of other objects that are nested from the patient objects that will be done automatically by the existing storage mechanism as long as there are no circle references. If further development requires storage of objects that are not nested from patient objects the storage mechanism needs to be updated to include two or more arrays instead of one; one containing the `JSON` representations of the `Patient` objects and the other/s containing the `JSON` representation of the other object/s. 

== Features

[[Feature-Switch-Autocorrect]]
=== Switch Autocorrect

If a user-supplied switch is _not_ an alias for any switch, this triggers the disambiguation functions in `CommandHelpers`. We use a modified Levnshtein-Damerau distance which takes into account distance on a standard QWERTY keyboard in weighting the cost of substitutions and transpositions (pseudocode from https://dl.acm.org/citation.cfm?doid=1963190.1963191[here] and ideas for implementation of keyboard distance analysis from https://stackoverflow.com/questions/29233888/[here]). The distance of the ambiguous string to every alias is calculated, with basic pruning implemented, terminating the distance estimation computation if it exceeds the minimum distance found so far.

If there is a switch with a unique lowest distance from the input string, that switch is automatically selected. If not, the user is prompted with a screen listing the closest matches, as well as all valid switches for this command. The closest matches are numbered, and the user may select one by entering its corresponding number, or he may enter another valid switch in its full form.


[appendix]
== Product Scope

*Target user profile*:

*House officers*, who are typically freshly-graduated medical students, play a vital role in managing hospital patients.
They are responsible, among many other things, for collating all information regarding each hospital patient and
organising it to provide a clear picture of the patient's situation, and for presenting that picture to senior doctors
who can then make assessments and recommendations based on that picture. As much of this information needs to be
exchanged at a rapid pace, *Dr. Duke* assists in quick, accurate and efficient recording and retrieval of the patient
data required to provide effective care.

The house officers we are targeting with this app:

* need to manage a significant number of patients
* need to quickly input and organise patient data
* prefer desktop apps over other types
* prefer typing over mouse input
* can type fast

*Value proposition*:

* input, organise and access information about patients faster than with a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="100%",cols="10%,30%,30%,30%",options="header"]
|=======================================================================
| Priority | As a ... | I want to ... | So that I can...
| `* * *` | house officer | check my patients' allergies | issue them with the appropriate medicine

| `* * *` | house officer who has to manage a lot of information | flag and view the critical issues to
follow up for each patient | complete the follow-up(s) as soon as possible

| `* * *` | house officer who has to manage many patients | view the previous medical history of my patients
| understand what has been done to manage/treat their conditions

| `* * *` | house officer who needs to input a lot of data quickly and is prone to mistyping | be able to make typing
errors but still have my input recognised | avoid having to waste time to retype my command

| `* * *` | house officer who needs to input a lot of data quickly and is prone to mistyping | confirm my input type and
modify it quickly if it is incorrect | avoid having to retype or tediously transfer entries that were input in the
wrong place

| `* * *` | house officer who needs to upload records into the hospital's health system | generate unified reports that
are fully compatible with the system | avoid having to manually input those records

| `* * *` | house officer keeping track of information for my consultant | keep track of whether or not I've checked
for the results of certain investigations | make sure the consultant is kept up-to-date

| `* * *` | house officer who has to manage a lot of information | easily link new information and follow-up items to
particular conditions | have a clearer picture of each condition and its corresponding management plan

| `* *` | house officer with a consultant that talks too fast | differentiate the types of input with just a single
control character | avoid having to waste time switching between windows

| `* *` | house officer who has to manage a lot of information | easily view and navigate through data associated with
particular conditions that particular patients have | have a clearer view of what that particular condition is

| `* *` | house officer who needs to input a lot of data quickly and is prone to mistyping | undo my previous commands |
quickly rectify mistakes made when inputting data

| `*` | house officer who has to manage a lot of information | search through all of the records of a patient | find all
the details relevant to a particular aspect of his/her care plan

| `*` | house officer who has to manage many patients | easily view all critical issues all my patients are facing by
level of importance | address them as soon as possible

| `*` | house officer who needs to input a lot of data quickly and is prone to mistyping | have my input automatically
checked to ensure it is of the right format | always be assured that I am inputting the right commands.
|=======================================================================

[appendix]
== Use Cases

(For all use cases, the *System* is `Dr. Duke` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== [[UC-1]] Use case: UC1 - Add a patient

*MSS*

. User requests to add a patient.
. Dr. Duke requests for details of the patient.
. User enters the requested details.
. Dr. Duke creates a new profile for the patient according to the specified details.
+
Use case ends.

*Extensions*

* 3a. Dr. Duke detects an error in the entered details.
+
** 3a1. Dr. Duke prompts the user with an error message and requests for the correct details.
** 3a2. User enters correct details.
** Steps 3a1 and 3a2 are repeated until the given details are valid.
** Use case resumes from Step 4.

[discrete]
=== [[UC-2]] Use case: UC2 - Edit a patient's details

*MSS*

. User searches for the patient <<UC-3,(UC-3)>>.
. Dr. Duke requests for new details of the patient.
. User enters new details of the patient.
. Dr. Duke updates the profile for the patient.
+
Use case ends.

*Extensions*

* 3a. Dr. Duke detects an error in the entered details.
+
** 3a1. Dr. Duke prompts the user with an error message and requests for the correct details.
** 3a2. User enters correct details.
** Steps 3a1 and 3a2 are repeated until the given details are valid.
** Use case resumes from Step 4.

[discrete]
=== [[UC-3]] Use case: UC3 - Search for a patient

*MSS*

. User enters the patient's name.
. Dr. Duke returns list of all relevant results.
. User selects the target patient in the list.
+
Use case ends.

*Extensions*

* 2a. The returned list is empty.
+
Use case ends.

[discrete]
=== [[UC-4]] Use case: UC4 - View a patient's records

*MSS*

. User searches for the patient <<UC-3,(UC-3)>>.
. Dr. Duke shows the detailed records of the patient.
+
Use case ends.

[discrete]
=== [[UC-5]] Use case: UC5 - Discharge a patient

*MSS*

. User searches for the patient <<UC-3,(UC-3)>> and requests to discharge him/her.
. Dr. Duke shows the details of the patient and requests for a confirmation.
. User confirms that the patient may be discharged.
. Dr. Duke generates a discharge report for the patient and delete his/her record from the system.
+
Use case ends.

*Extensions*

* a. At any time, User chooses to cancel the discharge operation.
+
** a1. Dr. Duke requests to confirm the cancellation.
** a2. User confirms the cancellation.
+
Use case ends.

[discrete]
=== [[UC-6]] Use case: UC6 - Generate a unified report for a patient

*MSS*

. User searches for the patient <<UC-3,(UC-3)>> and requests to generate a report on his/her current health condition.
. Dr. Duke generates a detailed report for the patient.
+
Use case ends.

[discrete]
=== [[UC-7]] Use case: UC7 - Undo previous command(s)
*Preconditions*: At least 1 command in the command history.

*MSS*

. User requests to undo previous command(s).
. Dr. Duke shows the list of command(s) to be reverted and requests for a confirmation.
. User reviews the command(s) and confirms the undo operation.
. Dr. Duke performs the undo operation and returns the system to an older state.
+
Use case ends.

[appendix]
== Non Functional Requirements

. The software should be portable, i.e. work on any <<mainstream-os,mainstream OS>> as long as the OS has Java `11` or
  above installed.
. The software should be able to hold up to 500 patients without a noticeable reduction in performance for
  typical usage.
. The software should work without internet access.
. The software should have good user documentation, which details all aspects of the software to assist new
  users on how to use this software.
. The software should have good developer documentation to allow developers to understand the design of the
  software easily so that they can further develop and enhance the software.
. The software should be easily testable.
. A user with an above average typing speed for regular English text should be able to accomplish most of his/her
  intended tasks faster using commands than using the mouse.
. All data transactions should be atomic - either they succeed and the persistent data storage is immediately updated,
  or they fail and the user is notified of that event, with the data being unchanged.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
* Windows
* macOS
* Linux
