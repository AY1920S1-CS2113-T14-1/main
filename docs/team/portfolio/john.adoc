= Project Portfolio for Dr. Duke
:site-section: DeveloperGuide
:sectnums:
:imagesDir: ../../images
:xrefstyle: full
:doctype: article
:repoURL: https://github.com/AY1920S1-CS2113-T14-1/main/tree/master

By: _John Khoo_ (https://github.com/aquohn[@aquohn])

== Project Description

_Dr. Duke_ is a cross-platform Java app designed to help medical house officers manage their patients' medical information more effectively. It uses a command line input with graphical feedback to allow users to quickly and easily input and retrieve data. It was designed a team consisting of myself and three other software engineering students at the National University of Singapore. It was morphed from an https://github.com/aquohn/duke[original codebase] primarily written by myself for _Duke_, a personal assistant app. This is the home page of Dr. Duke, which users will see when they first open the app:

.The UI of Dr. Duke
image::Ui.png[]

Do note the following conventions in this document:

* `Mark-up` is used to indicate a code literal. This can be a `method()`, a `Class`, an `ENUM_VALUE`, or `literal input`. It is generally used when discussing concrete implementation details, as opposed to abstract ideas, e.g. "patient" refers to an actual human patient, while `Patient` refers to the Patient class, or an object thereof, in *Dr. Duke*.
** A method may be specified with its arguments: `method(String strArg, int intArg)` in order to let the reader know what arguments it takes, or to differentiate between two methods with the same name but different arguments. However, unless explicitly stated, a `method()` specified without its arguments *does not* imply that the method takes no arguments. A method may be referred to without arguments after being introduced with its arguments for brevity.
* _Italics_ are used when introducing a new term or concept.

NOTE: This box draws attention to quirk or caveat that may not be obvious.

== Contributions

My role in the project was focused on parser and command logic: translating input from the user into commands to manipulate the app's data. I also developed and implemented several other features, notably a system for allowing the user to disambiguate the intended target of a command, and contributed to project planning and management and the class community. My code contributions can be found https://nuscs2113-ay1920s1.github.io/dashboard/#search=aquohn[here], and further details on my implemented features can be found in the User and Developer Guide excerpts below.

=== Primary Features

==== Parser

I wrote a simple parser for extracting commands, arguments, switches and switch arguments from a user's input and translating them into `Command` objects, which can be executed to perfrom the user's desired action. In order for my teammates to easily extend the system by creating more commands, I designed a system for specifying a command's operation, and the switches required for it, such that my parser would be able to automatically check the user's input to see if it matches the requirements of the command. We had decided to write our own parser instead of using a library as it was a relatively straightforward task and gave us much more control over the formats of our commands, and for providing feedback to the user based on his input.

==== Autocorrect

I additionally developed the switch autocorrect feature, which provided a system for automatically correcting typing mistakes made by the user when specifying switches. It is an enhancement to the parser, which identifies, using a custom metric based on the https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance[Damerau-Levenshtein distance], the edit distance between the user's input and each possible valid input. The Damerau-Levenshtein distance computation assigns equal weightage to transpositions (swapping adjacent characters), insertion, deletion and substitution. However, I had decided to enhance my implementation by weighing physical keyboard distance in computing the cost for substitutions, which would more accurately reflect the likelihood of a substitution typo. If there is a unique closest match to the string, then it is supplied to the user with a warning. If not, the user would be taken to separate context, from which they can select the correct value for the string. 

This enhancement is beneficial to our target group of house officers, who need to rapidly input and organise a large quantity of information regarding a patient. This would naturally lead to mistakes being made while typing. In order for the user's experience to be as smooth as possible in the face of mistakes, this feature provides robust automatic correction for errors, and where automatic correction fails, enables the user to correct his mistake with minimal disruption to his workflow. Further, it can be extended to other parts of the project, for example, for the `find` command, providing a powerful API that can mitigate the impact of user errors on the smoothness of their workflow.

The algorithm was implemented based on pseudocode from https://dl.acm.org/citation.cfm?doid=1963190.1963191[this paper]. The enhancement of considering weighted substitution costs was assisted by the discussion on https://stackoverflow.com/questions/29233888/edit-distance-such-as-levenshtein-taking-into-account-proximity-on-keyboard[this StackOverflow post].

=== Further Features

I additionally developed the following features:

* Commands in the `Impression` context: `new`, `edit`, `delete`, `move`, `priority`, `primary`, `status`, `result`, `open`
* Refactored helper functions into `PatientUtils`, `HomeUtils`, `ImpressionUtils`, `CommandUtils`
* Wrote `contains()`, `findByName()`, `find()` and `searchAll()` methods in `Patient`, `PatientData` and `Impression` to allow commands to find objects by name or part thereof
* General refactoring in `Impression` and `Patient`:
** Add methods `getFollowUpCountStr()` and `getCriticalCountStr()` to produce descriptor strings instead of getting and processing raw data
** `equals()` method to perform comparisons for tests
* An autocorrect system that was not able to be integrated with the codebase in time.

=== Additional Contributions

I was responsible for almost the entirety of the first draft of the User Guide, which served as an informal specification for our project.

My contributions also include:

* Starting discussions and proposing features on the issue tracker
* Creating an abstract class that performs the necessary setup for testing more complex features to simplify test writing
* Participating in forum 
** Reporting website issues and starting a https://github.com/nusCS2113-AY1920S1/forum/issues/11[tracker issue] for them
** Contributing a https://github.com/nusCS2113-AY1920S1/forum/issues/34[tip] to the forum
** Asking questions https://github.com/nusCS2113-AY1920S1/forum/issues/13[#13], https://github.com/nusCS2113-AY1920S1/forum/issues/15[#15], https://github.com/nusCS2113-AY1920S1/forum/issues/25[#25], https://github.com/nusCS2113-AY1920S1/forum/issues/43[#43], https://github.com/nusCS2113-AY1920S1/forum/issues/44[#44], https://github.com/nusCS2113-AY1920S1/forum/issues/58[#58], https://github.com/nusCS2113-AY1920S1/forum/issues/63[#63] and https://github.com/nusCS2113-AY1920S1/forum/issues/71[#71] to help clarify doubts.
** Contributing to discussions https://github.com/nusCS2113-AY1920S1/forum/issues/10[#10], https://github.com/nusCS2113-AY1920S1/forum/issues/12[#12], https://github.com/nusCS2113-AY1920S1/forum/issues/30[#30], https://github.com/nusCS2113-AY1920S1/forum/issues/33[#33], https://github.com/nusCS2113-AY1920S1/forum/issues/49[#49], https://github.com/nusCS2113-AY1920S1/forum/issues/61[#61]

== User Guide Excerpts

=== Usage

* This app manages multiple Patients.
Each Patient has one or more Impressions (diagnoses), and each Impression is supported by Evidence and treated by Treatments.
Evidence consists of Observations and Results.
Treatments consist of Plans, Investigations and Medicine.
* The different screens you can view are referred to as contexts.
Each context is associated with a particular set of data to display, and has its own set of commands.
* `priority` refers to how critical a Treatment or Evidence is. 0 means not urgent, excluding the item from the criticality system, 1 means critical.
The other values are not defined specifically but the greater they are, the lower the priority.
These lower priority levels are meant to remain flexible for the user to provide his desired level of fine-graining and task management.
** `priority` 1 generally refers to something that needs to be followed up on or investigated immediately, e.g. signs of severe complications. `priority` 1 items will be displayed prominently to remind the user to respond to it when treating the patient.
* `status` refers to the stage of completion of a Treatment. `<status name>` refers to the textual description for each stage of completion.

=== Specifying Commands

Commands consist of a command name, an argument, and some number of swtiches: settings for a command that modify its behavior.
Switches can also have arguments.

For example, `discharge "John Doe" -sum "John Doe was discharged on 9 October 2019 at 3:54 pm."` represents the command `discharge` with the argument `"John Doe"`, modified by the switch `-sum` (meaning "summary"), which has the switch argument `"John Doe was discharged on 9 October 2019 at 3:54 pm."`.

Only a few characters have a special meaning when you are giving Dr. Duke commands.
These are `"`, `\`, `-`, `<Space>`, and `<Enter>`:

* `"` -> Indicates the start and end of a string: text input that is longer than a single word.
* `\` -> Escape character: the special character after a backslash loses its special meaning.
To type a literal backslash, you need to escape the backslash: `Hello\\World` becomes `Hello\World`.
* `-` -> Indicates the start of a switch.
Must immediately be followed by an argument, if the switch requries one.
* `<Space>` -> Words in a command are separated by spaces.
* `<Enter>` -> This sends a command to Dr. Duke. `<Shift-Enter>` would insert a new line.

The documentation below uses the following notation to describe the structure of the commands recognised:

* `[]` -> optional element of a command
* `<>` -> input of the type specified
* `(a | b | c)` -> input that can be one of several possible options, in this case `a`, `b` or `c`
* `"<>"` -> string, must be surrounded by quotes if it contains a space (or escape the space with a backslash)
* `[]*` -> 0 or more copies of the contents of `[]`, separated by spaces

The following italicised words refer to specific repeated patterns:

// TODO: Part of name
* _patient_id_ -> `(<patient's index> | "<part of name>" | *-b[ed]* <bed number>)`
* _string_or_idx_ -> `(<index> | "<search string>")`
** `<index>` refers to the index assigned to the object in the display. `<search string>` will be searched for in the names of all relevant objects.
* _type_ -> (`-m[edicine]` | `-in[v(x | estigation)]` | `-p[lan]` | `-o[bservation]` | `-r[esult]`)

Parsing rules:

* Switches can be in any order
* Switches with optional parts of their names can be recognised with any portion of the optional part. E.g. `-crit` matches `-c[ritical]`.
* If it is ambiguous whether an argument is for the command itself, or one of the switches, it will be presumed to belong to the switch.


=== Impression [[impression]]

Shows a detailed view of an Impression, displaying in separate panels:

* The name and full description of the Impression
* A list of Evidence for the Impression, sorted by default with critical items first
* A list of Treatments for the Impression, sorted by default with critical items first, followed by investigations that require follow-up
* A small panel with the patient's allergies

Inherits: <<home-help,`help`>>, <<patient-back,`back`>>, <<patient-up,`up`>>, <<patient-report,`report`>>, <<home-undo,`undo`>>, <<home-redo,`redo`>>

==== `new` - Add a new Treatment or Evidence item to this Impression

Format: `new _type_ <relevant switches> [-g[o]]`

Open the new Treatment or Evidence item's context if `-g[o]` is specified.
Relevant switches for various types are as follows.

[[type-table]]
[cols=2*,options="header"]
|===
|Type
|Relevant Switches

|`-m[edicine]`
a|
* `-n[ame] "<name>"` - Required
* `-sta[tus] ("<status name>"\|<status idx>)` - Default: 0 (not ordered)
* `-d[ose] "<dose>"` - Required
* `-da[te] "<start date>"` - Default: Today
* `-du[ration] "<duration of course>"` - Required
* `-pri[ority] <priority idx>` - Default: 0 (not urgent)

|`-i[nv(x\|estigation)]`
a|
* `-n[ame] "<name>"` - Required
* `-sta[tus] ("<status name>"\|<status idx>)` - Default: 0 (not ordered)
* `-sum[mary] "<summary>"` - Default: ""
* `-pri[ority] <priority idx>` - Default: 0 (not urgent)

|`-p[lan]`
a|
* `-n[ame] "<name>"` - Required
* `-sta[tus] ("<status name>"\|<status idx>)` - Default: 0 (not ordered)
* `-sum[mary] "<summary>"` - Default: ""
* `-pri[ority] <priority idx>` - Default: 0 (not urgent)

|`-o[bservation]`
a|
* `-n[ame] "<name>"` - Required
* `-sum[mary] "<summary>"` - Default: ""
* `-(subj[ective]\|obj[ective])` - Default: objective observations
* `-pri[ority] <priority idx>` - Default: 0 (not urgent)

|`-r[esult]`
a|
* `-n[ame] "<name>"` - Required
* `-sum[mary] "<summary>"` - Default: ""
* `-pri[ority] <priority idx>` - Default: 0 (not urgent)

|===

`<status name>` is a case-insensitive substring of the `statusArr` entry of that particular object, while `<status idx>` is its numerical representation.

==== `edit` - Edit one of the details of the Impression

Format: `edit [-app[end]] [_type_ _string_or_idx_] <switch> [<new value>] [<switch> [<new value>]]`

If input without `_type_ _string_or_idx_`, the switches and corresponding new value formats are as follows:

* `-n[ame] "<name>"`
* `-desc[ription] "<description>"`

With an additional type switch, the command instead edits an associated Treatment or Evidence.
The possible values for `<switch>` and `<new value>` can be found in the associated <<type-table,table>> for `new`.

== Developer Guide Excerpts

[[Design-Logic]]
=== Parser Logic [JOHN CUTHBERT KHOO TENG FONG]
image::plantuml/logic.svg[]

This class diagram describes the relationships between the various core classes involved in parsing the user's input into `Commands`. The first word (delimited by a space or newline) of the user's input is the _command name_. All commands extend the `Command` abstract class, which provides enough functionality for basic commands consisting of a single word. The operation of the `Command` is specified in the `execute` method. The mapping from the command name to the `Command` should be created in the `Commands` class, which is loaded by the default `Parser` constructor, together with a reference to a `Context` enum (ordinarily, a reference to the `context` field in the `DukeCore` instance). A `Parser` can also be constructed with a subclass of `Commands` to specify a different set of commands.

The `Commands` class has a single function `getCommand()`, which takes, as arguments, a String that should uniquely identify the requested `Command` within a particular `Context`, and a `Context` enum representing the context from which the `Command` was called. It constructs and returns a new instance of the `Command` object thus identified.

==== Commands

If a `Command` has no arguments, the newly constructed instance is returned without further processing. If it takes any arguments, it extends `ArgCommand`. Each `ArgCommand` is associated with an `ArgSpec` singleton, whose private constructor sets the parameters of the `ArgCommand`: `emptyArgMsg` (the error message when no argument is supplied), `cmdArgLevel` (an `ArgLevel` enum indicating whether an argument for the command is necessary, optional, or forbidden) and the data structures `switchMap` and `switchAliases`, generated by the `switchInit()` function. The `switchInit()` function takes a vararg of `Switch` objects, which should specify the switches for the particular `Command`.

`switchMap` maps the full name of a switch to a `Switch` object, describing its properties, and `switchAliases` maps _aliases_ to the full name of the switch they represent. An alias is a string that, when provided by the user as a switch, is recognised as a specific switch. For example, for the switch `investigation` (given as `-i[nv(x|estigation)` in the User Guide) has the following aliases: `i`, `in`, `inv`, `invx`, `inve`, `inves`, `invest`, `investi`, `investig`, `investiga`, `investigat`, `investigati`, `investigatio`, `investigation`.

As this would be very tedious to list manually, it is automatically generated by the `switchInit()` function, using the data in the `Switch` objects provided to it. Observe that almost all these aliases are prefixes of the word `investigation`, with the shortest being `i`. This follows from the requirement that the switch can be recognised as long as the user has input enough characters for it to be unambiguous. Let `i` in this example be the _root_, the shortest unambiguous part of the full name of the switch. Then, every prefix of the word `investigation` starting from the root is an alias of the switch `investigation`. All aliases of this form are generated by a loop in `switchInit()`, from the root and the full name in the `Switch` object. Any additional aliases can be supplied via the `aliases` vararg in the `Switch` constructor. Refer to the Javadoc of `Switch` for further details on its fields.

In summary, to define a new `Command`:

. Define a subclass of `Command`
. Specify its execution in `execute`
. Update `Commands` to link the command name to the `Command`

If this is an `ArgCommand`, in addition to doing the above for a subclass of `ArgCommand`:

. Define a subclass of `ArgSpec` (by convention, `<name>Spec` is associated with `<name>Command`)
. Define the private static field `spec` and the public static method `getSpec()` to provide singleton behaviour
. Create a private constructor for the subclass
.. Define `cmdArgLevel` and `emptyArgMsg`
.. Construct the switches for the `ArgCommand` and supply them as arguments to `switchInit()`
... If there are no switches, call `switchInit()` with no arguments

Switch values are accessed from the `ArgCommand` with the `getSwitchVal()` method, which takes the name of a switch, as a String, as an argument, and returns the String representing the argument supplied for the switch. 

NOTE: If there is no argument given for a switch, `getSwitchVal(<switch name>)` returns `null`. However, if a switch is not given, `getSwitchVal(<switch name>)` also returns `null`. The former case can be distinguished by the fact that `switchVals` will contain `<switch name>` as a key.

==== Parsing

The `Parser` object scans through a user-supplied string. The first word is extracted, and if the corresponding command is an `ArgCommand`, it uses a finite state machine (FSMs) which switches on the characters in the input. Switches are extracted, using the aliases in `switchAliases` to identify the full names of the corresponding switches. The switch arguments are then compared against the requirements of the `ArgCommand`, as stored in the `switchMap`.

The finite state machine for input parsing has the following states:

* `CMDARG`: parsing the argument for the command
* `EMPTY`: parsing whitespace, which has no semantic meaning aside from serving as a separator
* `ARG`: parsing an argument for a switch
* `SWITCH`: parsing a switch name

The state transitions on encountering would not be clearly represented on a state diagram, but can be summarised as follows:

* `CMDARG` 
** `CMDARG` -> `SWITCH`: `-`
** `CMDARG` -> `CMDARG`: any other character, which will be appended to the command's argument
* `SWITCH` 
** `SWITCH` -> `SWITCH`: `-` to start a new switch, any other character to append characters to the switch name
** `SWITCH` -> `EMPTY`: <Space> or <Newline>
* `EMPTY` 
** `EMPTY` -> `SWITCH`: `-`
** `EMPTY` -> `EMPTY`: <Newline> or <Space>, which is skipped over
** `EMPTY` -> `ARG`: any other character, which will initiate the construction of the argument for the previous switch
* `ARG` 
** `ARG` -> `SWITCH`: `-` marks the end of a switch's argument, and the beginning of a new switch

Preceding any transition character with a backslash `\` will escape it, allowing it to be treated as an ordinary character.

When transitioning from `EMPTY` to any other state, `checkInputAllowed()` is used to check if input is allowed at that point. While in the `ARG`, `STRING` or `SWITCH` states, each character that is read is added to a StringBuilder `elementBuilder`. When exiting the state, the string is processed as a switch via `addSwitch()`, or written to the `Command` being constructed as an argument by `writeElement()`. This can be an argument for the `Command` itself, or a switch argument. For more details on how switches are processed, see above on `Command` objects, and on the <<Feature-Switch-Autocorrect,Switch Autocorrect>> feature.

When every character in the input has been consumed, cleanup will be performed based on the state that the `Parser` is in at that point:

* `EMPTY`: nothing is done
* `ARG`: call `writeElement()` to write the switch argument being processed
* `SWITCH`: call `addSwitch()` to process and add the switch, and update `switchVals` in the corner case where the command ends with a switch with an optional argument, which is not given.
* `CMDARG`: call `setCmdArg()`

[[Feature-Switch-Autocorrect]]
=== Switch Autocorrect 

==== Rationale

While rapidly adding different types of patient data, it is inevitable that typing mistakes will be made. While short forms of switches are accepted in order to minimise the amount of typing that needs to be done to organise information, and therefore the risk of mistakes being made, we still need to account for the cases where they occur. An automated means of correcting the text would allow these corrections to be made as quickly as possible and with minimal effort required from the user, reducing the disruption to his workflow caused by these mistakes.

==== Implementation

If a user-supplied switch is _not_ an alias for any switch, this triggers the disambiguation functions in `CommandHelpers`. We use a modified Levenshtein-Damerau distance which takes into account the taxicab distance between keys on a standard QWERTY keyboard in weighting the cost of substitutions. Pseudocode for the Levenshtein-Damerau distance computation can be found https://dl.acm.org/citation.cfm?doid=1963190.1963191[here] and ideas for implementation of keyboard distance analysis are taken from https://stackoverflow.com/questions/29233888/[here]. This provides a realistic measure of the likelihood that a particular mistake was made, as the likelihood of accidentally pressing an incorrect key is dramatically decreased if the incorrect key in question is a keyboard's length away from one's intended key, which is a fact that the basic Levenshtein-Damerau distance algorithm fails to capture. 

The distance of the ambiguous string to every alias whose length differs from the string's by at most 2 is calculated. Basic pruning is implemented, terminating the distance estimation computation if it exceeds the minimum distance found so far.

If there is a switch with a unique lowest distance from the input string, that switch is automatically selected, with a warning shown to the user to indicate that his input was autocorrected. If not, the user is prompted with a screen listing the closest matches, as well as all valid switches for this command. The closest matches are numbered, and the user may select one by entering its corresponding number, or he may enter another valid switch in its full form.

==== Comparison with Alternatives

Taxicab distance is used as opposed to Euclidean in order to avoid computing square roots, and only the substitution cost is affected by the keyboard distance, as having missed or accidentally added a character, or typing the characters out of sequence, is not dependent on the distance between two keys.

This function is called by the parser finite state machine whenever a complete switch that does not match any alias is processed, instead of presenting all combinations of possible corrections after the whole input is parsed. This allows mistyped switches to be individually and unambiguously corrected, instead of creating a confusing combinatorical explosion of possible switches if the user makes several mistakes in a complex query, some of which may have more than two close matches for a switch if the user had used their shortened forms.
